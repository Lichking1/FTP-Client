#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>


#define MAXBUF             1024        //宏大小
#define STDIN_FILENO     1            //标准输入
#define STDOUT_FILENO     0            //标准输出


#define USERNAME     220            //用户名
#define PASSWORD      331            //密码
#define LOGIN           230            //登录
#define PATHNAME      257            //路径名
#define CLOSEDATA     226            //    
#define ACTIONOK      250            //


char *rbuf,*rbuf1,*wbuf,*wbuf1;


char filename[100];                    //文件名
char *host;                            //要连接的服务器地址


struct sockaddr_in servaddr;        //服务器的地址、端口结构体

//1.第一步，打开一个TCP链接
int cliopen(char *host,int port);
//
int strtosrv(char *str);
int ftp_get(int sck,char *pDownloadFileName);
int ftp_put(int sck,char *pUploadFileName_s);
void cmd_tcp(int sockfd);                        //

//主函数
int main(int argc,char *argv[])
{
    int fd;

    //判断输入参数
    if(0 != argc -2)
    {
        printf("%s\n","missing <hostname>");
        exit(0);
    }

    //指定服务器地址
    host = argv[1];
    //指定端口
    int port = 21;
   
    rbuf = (char *)malloc(MAXBUF*sizeof(char));
    rbuf1 = (char *)malloc(MAXBUF*sizeof(char));
    wbuf = (char *)malloc(MAXBUF*sizeof(char));
    wbuf1 = (char *)malloc(MAXBUF*sizeof(char));

    //1.得到已连接的套接字
    fd = cliopen(host,port);

    //2.
    cmd_tcp(fd);
    
    exit(0);
}




//1.第一步，打开一个TCP链接
int cliopen(char *host,int port)
{
    int control_sock;

    //1.FTP 自己的传输地址结构体
    struct hostent *ht = NULL;

    //2.创建套接字
    control_sock = socket(AF_INET,SOCK_STREAM,0);
    if(control_sock < 0)
    {
       printf("socket error\n");
       return -1;
    }

    //3.将IP地址进行转换，变为FTP地址结构体
    ht = gethostbyname(host);
    if(!ht)
    { 
        return -1;
    }
    
   //4.连接服务器，返回套接字
    memset(&servaddr,0,sizeof(struct sockaddr_in));
    memcpy(&servaddr.sin_addr.s_addr,ht->h_addr,ht->h_length);
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(port);
    
    if(connect(control_sock,(struct sockaddr*)&servaddr,sizeof(struct sockaddr)) == -1)
    {
        return -1;
    }
    return control_sock;
}

//匹配下载的文件名
int s(char *str,char *s2)
{
    //char s1[100];
     
    return sscanf(str," get %s",s2) == 1;
   
}

//匹配上传的文件名
int st(char *str,char *s1)
{
    return sscanf(str," put %s",s1) == 1;
}

//获取服务器 发送给 客户端的 IP地址 和 端口;
int strtosrv(char *str)
{
   int addr[6];
   //printf("%s\n",str);
   sscanf(str,"%*[^(](%d,%d,%d,%d,%d,%d)",&addr[0],&addr[1],&addr[2],&addr[3],&addr[4],&addr[5]);
   bzero(host,strlen(host));
   sprintf(host,"%d.%d.%d.%d",addr[0],addr[1],addr[2],addr[3]);
   int port = addr[4]*256 + addr[5];
   return port;
}

//显示文件列表
void ftp_list(int sockfd)
{
    int nread;
    for(;;)
    {
        if((nread = recv(sockfd,rbuf1,MAXBUF,0)) < 0)
        {
            printf("recv error\n");
        }
        else if(nread == 0)
        {
            //printf("over\n");
            break;
        }
        if(write(STDOUT_FILENO,rbuf1,nread) != nread)
            printf("send error to stdout\n");
        /*else
            printf("read something\n");*/
    }
    if(close(sockfd) < 0)
        printf("close error\n");
}

//下载文件
int ftp_get(int sck,char *pDownloadFileName)
{
   int handle = open(pDownloadFileName,O_WRONLY | O_CREAT | O_TRUNC, S_IREAD| S_IWRITE);
   int nread;
   printf("%d\n",handle);
   /*if(handle == -1) 
       return -1;*/

    //2. 猜测 ====================应该是将 ssl 接口放在这里，用来传输数据
   
   for(;;)
   {
       if((nread = recv(sck,rbuf1,MAXBUF,0)) < 0)
       {
          printf("receive error\n");
       }
       else if(nread == 0)
       {
          printf("over\n");
          break;
       }
    //   printf("%s\n",rbuf1);
       if(write(handle,rbuf1,nread) != nread)
           printf("receive error from server!");
       if(write(STDOUT_FILENO,rbuf1,nread) != nread)
           printf("receive error from server!");
   }
       if(close(sck) < 0)
           printf("close error\n");
}


//上传文件
int ftp_put(int sck,char *pUploadFileName_s)
{
   //int c_sock;
   int handle = open(pUploadFileName_s,O_RDWR);
   int nread;
   if(handle == -1)
       return -1;
   //ftp_type(c_sock,"I");

   //3. 猜测 ====================应该是将 ssl 接口放在这里，用来传输数据
   for(;;)
   {
       if((nread = read(handle,rbuf1,MAXBUF)) < 0)
       {
            printf("read error!");
       }
       else if(nread == 0)
          break;
       if(write(STDOUT_FILENO,rbuf1,nread) != nread)
            printf("send error!");
       if(write(sck,rbuf1,nread) != nread)
            printf("send error!");
   }
   if(close(sck) < 0)
        printf("close error\n");
}



//各种参数的执行
void cmd_tcp(int sockfd)
{
    int maxfdp1,nread,nwrite,fd,replycode,tag=0,data_sock;
    int port;
    char *pathname;
    fd_set rset;                //可读文件描述符集合
    FD_ZERO(&rset);                //清空可读文件描述符集合
    maxfdp1 = sockfd + 1;        //最大套接字

    for(;;)
    {
        //1.将  标准输入加入 可读文件描述符集合
         FD_SET(STDIN_FILENO,&rset);
        //2.将  命令套接字   加入可读文件描述符集合
         FD_SET(sockfd,&rset);

        //3.监听读事件
         if(select(maxfdp1,&rset,NULL,NULL,NULL)<0)
         {
             printf("select error\n");
         }
         //4.判断标准输入是否有读事件
         if(FD_ISSET(STDIN_FILENO,&rset))
         {
             //5.清空读缓冲区 和 写缓冲区
              bzero(wbuf,MAXBUF);          //zero
              bzero(rbuf1,MAXBUF);
              
              if((nread = read(STDIN_FILENO,rbuf1,MAXBUF)) <0)
                   printf("read error from stdin\n");
              nwrite = nread + 5;

            //=======这里不懂，replycode  什么时候赋的值

            //6.命令套接字中  写入  用户名
              if(replycode == USERNAME) 
              {
                  sprintf(wbuf,"USER %s",rbuf1);
              
                 if(write(sockfd,wbuf,nwrite) != nwrite)
                 {
                     printf("write error\n");
                 }
                 //printf("%s\n",wbuf);
                 //memset(rbuf1,0,sizeof(rbuf1));
                 //memset(wbuf,0,sizeof(wbuf));
                 //printf("1:%s\n",wbuf);
              }

            //7.命令套接字中  写入  密码                
              if(replycode == PASSWORD)
              {
                   //printf("%s\n",rbuf1);
                   sprintf(wbuf,"PASS %s",rbuf1);
                   if(write(sockfd,wbuf,nwrite) != nwrite)
                      printf("write error\n");
                   //bzero(rbuf,sizeof(rbuf));
                   //printf("%s\n",wbuf);
                   //printf("2:%s\n",wbuf);
              }
              
              if(replycode == 550 || replycode == LOGIN || replycode == CLOSEDATA || replycode == PATHNAME || replycode == ACTIONOK)
              {
              if(strncmp(rbuf1,"pwd",3) == 0)
              {   
                     //printf("%s\n",rbuf1);
                     sprintf(wbuf,"%s","PWD\n");
                     write(sockfd,wbuf,4);
                     continue; 
                 }
                 if(strncmp(rbuf1,"quit",4) == 0)
                 {
                     sprintf(wbuf,"%s","QUIT\n");
                     write(sockfd,wbuf,5);
                     //close(sockfd);
                    if(close(sockfd) <0)
                       printf("close error\n");
                    break;
                 }
                 if(strncmp(rbuf1,"cwd",3) == 0)
                 {
                     //sprintf(wbuf,"%s","PASV\n");
                     sprintf(wbuf,"%s",rbuf1);
                     write(sockfd,wbuf,nread);
                     
                     //sprintf(wbuf1,"%s","CWD\n");
                     
                     continue;
                 }
                 
                 if(strncmp(rbuf1,"ls",2) == 0)
                 {
                     tag = 2;            //显示文件 标识符
                     //printf("%s\n",rbuf1);
                     sprintf(wbuf,"%s","PASV\n");
                     //printf("%s\n",wbuf);
                     write(sockfd,wbuf,5);
                     //read
                     //sprintf(wbuf1,"%s","LIST -al\n");
                     nwrite = 0;
                     //write(sockfd,wbuf1,nwrite);
                     //ftp_list(sockfd);
                     continue;    
                 }
                 //8.下载文件
                 if(strncmp(rbuf1,"get",3) == 0)
                 {
                     tag = 1;            //下载文件标识符

                     //被动传输模式    
                     sprintf(wbuf,"%s","PASV\n");                   
                     //printf("%s\n",s(rbuf1));
                     //char filename[100];
                     s(rbuf1,filename);
                     printf("%s\n",filename);
                     write(sockfd,wbuf,5);
                     continue;
                 }
                 
                 if(strncmp(rbuf1,"put",3) == 0)
                 {
                     tag = 3;            //上传文件标识符
                     sprintf(wbuf,"%s","PASV\n");

                    //把内容赋值给  读缓冲区
                     st(rbuf1,filename);
                     printf("%s\n",filename);
                     write(sockfd,wbuf,5);
                     continue;
                 }
              } 
                    /*if(close(sockfd) <0)
                       printf("close error\n");*/
         }
         if(FD_ISSET(sockfd,&rset))
         {
         //9.清空读缓冲区 和 写缓冲区
             bzero(rbuf,strlen(rbuf));
         //10.读套接字中的内容
             if((nread = recv(sockfd,rbuf,MAXBUF,0)) <0)
                  printf("recv error\n");
             else if(nread == 0)
               break;

           //比较
             if(strncmp(rbuf,"220",3) ==0 || strncmp(rbuf,"530",3)==0)
             {
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/

                 //链接字符串
                 strcat(rbuf,"your name:");
                
                 //printf("%s\n",rbuf);
                 nread += 12;
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/
                 replycode = USERNAME;
             }
             if(strncmp(rbuf,"331",3) == 0)
             {
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n")*/;
                strcat(rbuf,"your password:");
                nread += 16;
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/
                replycode = PASSWORD;
             }
             if(strncmp(rbuf,"230",3) == 0)
             {
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/
                replycode = LOGIN;
             }
             if(strncmp(rbuf,"257",3) == 0)
             {
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/
                replycode = PATHNAME;  
             }
             if(strncmp(rbuf,"226",3) == 0)
             {
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/
                replycode = CLOSEDATA;
             }
             if(strncmp(rbuf,"250",3) == 0)
             {
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");*/
                replycode = ACTIONOK;
             }
             if(strncmp(rbuf,"550",3) == 0)
             {
                replycode = 550;
             }
             /*if(strncmp(rbuf,"150",3) == 0)
             {
                if(write(STDOUT_FILENO,rbuf,nread) != nread)
                    printf("write error to stdout\n");
             }*/    
             //fprintf(stderr,"%d\n",1);
             if(strncmp(rbuf,"227",3) == 0)
             {
                //printf("%d\n",1);
                /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                   printf("write error to stdout\n");*/

                //获取服务器返回的 接收数据的端口，和地址
                int port1 = strtosrv(rbuf);
                printf("%d\n",port1);
                printf("%s\n",host);

                //创建新的传输数据的套接字?
                //1. 猜测 ====================应该是将 ssl 接口放在这里，用来传输数据
                data_sock = cliopen(host,port1);
        


//bzero(rbuf,sizeof(rbuf));
                //printf("%d\n",fd);
                //if(strncmp(rbuf1,"ls",2) == 0)
                if(tag == 2)
                {
                   write(sockfd,"list\n",strlen("list\n"));
                   ftp_list(data_sock);
                   /*if(write(STDOUT_FILENO,rbuf,nread) != nread)
                       printf("write error to stdout\n");*/
                   
                }
                //else if(strncmp(rbuf1,"get",3) == 0)
                else if(tag == 1)
                {
                    //sprintf(wbuf,"%s","RETR\n");
                    //printf("%s\n",wbuf);
                    //int str = strlen(filename);
                    //printf("%d\n",str);
                    sprintf(wbuf,"RETR %s\n",filename);
                    printf("%s\n",wbuf);
                    //int p = 5 + str + 1;

                    //命令套接字中写入  下载文件命令
                    printf("%d\n",write(sockfd,wbuf,strlen(wbuf)));
                    //printf("%d\n",p);

                    //下载文件 
                    ftp_get(data_sock,filename);
                }
                else if(tag == 3)
                {

                    // 上传文件
                    sprintf(wbuf,"STOR %s\n",filename);
                    printf("%s\n",wbuf);
                    write(sockfd,wbuf,strlen(wbuf));
                    ftp_put(data_sock,filename);
                }
                nwrite = 0;     
             }
             /*if(strncmp(rbuf,"150",3) == 0)
             {
                 if(write(STDOUT_FILENO,rbuf,nread) != nread)
                     printf("write error to stdout\n");
             }*/
             //printf("%s\n",rbuf);
             if(write(STDOUT_FILENO,rbuf,nread) != nread)
                 printf("write error to stdout\n");
             /*else 
                 printf("%d\n",-1);*/            
         }
    }
}
